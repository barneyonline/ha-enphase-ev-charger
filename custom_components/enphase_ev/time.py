from __future__ import annotations

from datetime import time as dt_time
import logging
import re

from homeassistant.components.time import TimeEntity
from homeassistant.core import HomeAssistant, callback
from homeassistant.helpers import entity_registry as er
from homeassistant.helpers.entity import DeviceInfo
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import DOMAIN
from .coordinator import EnphaseCoordinator
from .runtime_data import EnphaseConfigEntry, get_runtime_data

PARALLEL_UPDATES = 0
_LOGGER = logging.getLogger(__name__)
_AUTO_SUFFIX_RE = re.compile(r"^\d+$")


def _time_entity_id_migrations(coord: EnphaseCoordinator) -> dict[str, tuple[str, str]]:
    return {
        f"{DOMAIN}_site_{coord.site_id}_charge_from_grid_start_time": (
            "time.charge_from_grid_start_time",
            "time.charge_from_grid_schedule_from_time",
        ),
        f"{DOMAIN}_site_{coord.site_id}_charge_from_grid_end_time": (
            "time.charge_from_grid_end_time",
            "time.charge_from_grid_schedule_to_time",
        ),
    }


def _migrated_time_entity_id(
    current_entity_id: str, legacy_entity_id: str, target_entity_id: str
) -> str | None:
    """Return the target entity_id for legacy/default IDs, else None."""
    if current_entity_id == legacy_entity_id:
        return target_entity_id

    # Migrate legacy auto-suffixed IDs generated by HA object-id collisions.
    legacy_prefix = f"{legacy_entity_id}_"
    if not current_entity_id.startswith(legacy_prefix):
        return None

    suffix = current_entity_id[len(legacy_prefix) :]
    if not _AUTO_SUFFIX_RE.fullmatch(suffix):
        return None
    return f"{target_entity_id}_{suffix}"


def _site_has_battery(coord: EnphaseCoordinator) -> bool:
    has_encharge = getattr(coord, "battery_has_encharge", None)
    return has_encharge is not False


def _type_available(coord: EnphaseCoordinator, type_key: str) -> bool:
    has_type_for_entities = getattr(coord, "has_type_for_entities", None)
    if callable(has_type_for_entities):
        return bool(has_type_for_entities(type_key))
    has_type = getattr(coord, "has_type", None)
    return bool(has_type(type_key)) if callable(has_type) else True


async def async_setup_entry(
    hass: HomeAssistant,
    entry: EnphaseConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    coord: EnphaseCoordinator = get_runtime_data(entry).coordinator
    site_entities_added = False

    ent_reg = er.async_get(hass)
    rename_by_unique = _time_entity_id_migrations(coord)
    for registry_entry in er.async_entries_for_config_entry(ent_reg, entry.entry_id):
        migration = rename_by_unique.get(registry_entry.unique_id)
        if migration is None:
            continue
        legacy_entity_id, target_entity_id = migration
        if registry_entry.entity_id == target_entity_id:
            continue
        migrated_entity_id = _migrated_time_entity_id(
            registry_entry.entity_id, legacy_entity_id, target_entity_id
        )
        # Respect user-customized entity IDs; only migrate known legacy defaults.
        if migrated_entity_id is None:
            continue
        try:
            ent_reg.async_update_entity(
                registry_entry.entity_id,
                new_entity_id=migrated_entity_id,
            )
        except ValueError:
            _LOGGER.debug(
                "Could not rename %s to %s while migrating Charge From Grid schedule entities",
                registry_entry.entity_id,
                migrated_entity_id,
            )

    @callback
    def _async_sync_site_entities() -> None:
        nonlocal site_entities_added
        if site_entities_added:
            return
        if not _site_has_battery(coord) or not _type_available(coord, "encharge"):
            return
        async_add_entities(
            [ChargeFromGridStartTimeEntity(coord), ChargeFromGridEndTimeEntity(coord)],
            update_before_add=False,
        )
        site_entities_added = True

    unsubscribe = coord.async_add_listener(_async_sync_site_entities)
    entry.async_on_unload(unsubscribe)
    _async_sync_site_entities()


class _BaseChargeFromGridTimeEntity(CoordinatorEntity, TimeEntity):
    _attr_has_entity_name = True

    def __init__(self, coord: EnphaseCoordinator, suffix: str) -> None:
        super().__init__(coord)
        self._coord = coord
        self._attr_unique_id = f"{DOMAIN}_site_{coord.site_id}_{suffix}"

    @property
    def available(self) -> bool:  # type: ignore[override]
        if not super().available:
            return False
        return (
            _type_available(self._coord, "encharge")
            and self._coord.charge_from_grid_schedule_available
        )

    @property
    def device_info(self) -> DeviceInfo:
        type_device_info = getattr(self._coord, "type_device_info", None)
        info = type_device_info("encharge") if callable(type_device_info) else None
        if info is not None:
            return info
        return DeviceInfo(
            identifiers={(DOMAIN, f"type:{self._coord.site_id}:encharge")},
            manufacturer="Enphase",
        )


class ChargeFromGridStartTimeEntity(_BaseChargeFromGridTimeEntity):
    _attr_translation_key = "charge_from_grid_start_time"

    def __init__(self, coord: EnphaseCoordinator) -> None:
        super().__init__(coord, "charge_from_grid_start_time")

    @property
    def suggested_object_id(self) -> str | None:
        return "charge_from_grid_schedule_from_time"

    @property
    def native_value(self) -> dt_time | None:
        return self._coord.battery_charge_from_grid_start_time

    async def async_set_value(self, value: dt_time) -> None:
        await self._coord.async_set_charge_from_grid_schedule_time(start=value)


class ChargeFromGridEndTimeEntity(_BaseChargeFromGridTimeEntity):
    _attr_translation_key = "charge_from_grid_end_time"

    def __init__(self, coord: EnphaseCoordinator) -> None:
        super().__init__(coord, "charge_from_grid_end_time")

    @property
    def suggested_object_id(self) -> str | None:
        return "charge_from_grid_schedule_to_time"

    @property
    def native_value(self) -> dt_time | None:
        return self._coord.battery_charge_from_grid_end_time

    async def async_set_value(self, value: dt_time) -> None:
        await self._coord.async_set_charge_from_grid_schedule_time(end=value)
